{"ast":null,"code":"var _jsxFileName = \"/Users/adila/Desktop/face-recognition-adila/src/views/VideoInput.js\";\nimport React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face'; // Import face profile\n\nconst JSON_PROFILE = require('../descriptors/bnk48.json');\n\nconst WIDTH = 420;\nconst HEIGHT = 420;\nconst inputSize = 160;\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n\n    this.componentWillMount = async () => {\n      await loadModels();\n      this.setState({\n        faceMatcher: await createMatcher(JSON_PROFILE)\n      });\n      this.setInputDevice();\n    };\n\n    this.setInputDevice = () => {\n      navigator.mediaDevices.enumerateDevices().then(async devices => {\n        let inputDevice = await devices.filter(device => device.kind === 'videoinput');\n\n        if (inputDevice.length < 2) {\n          await this.setState({\n            facingMode: 'user'\n          });\n        } else {\n          await this.setState({\n            facingMode: 'user' //facingMode: { exact: 'environment' } //capture from back camera\n\n          });\n        }\n\n        this.startCapture();\n      });\n    };\n\n    this.startCapture = () => {\n      this.interval = setInterval(() => {\n        this.capture();\n      }, 1500);\n    };\n\n    this.capture = async () => {\n      if (!!this.webcam.current) {\n        await getFullFaceDescription(this.webcam.current.getScreenshot(), inputSize).then(fullDesc => {\n          if (!!fullDesc) {\n            this.setState({\n              detections: fullDesc.map(fd => fd.detection),\n              descriptors: fullDesc.map(fd => fd.descriptor)\n            });\n          }\n        });\n\n        if (!!this.state.descriptors && !!this.state.faceMatcher) {\n          let match = await this.state.descriptors.map(descriptor => this.state.faceMatcher.findBestMatch(descriptor));\n          this.setState({\n            match\n          });\n        }\n      }\n    };\n\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      descriptors: null,\n      faceMatcher: null,\n      match: null,\n      facingMode: null\n    };\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    const _this$state = this.state,\n          detections = _this$state.detections,\n          match = _this$state.match,\n          facingMode = _this$state.facingMode;\n    let videoConstraints = null;\n    let camera = '';\n\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n\n      if (facingMode === 'user') {\n        camera = 'Front';\n      } else {\n        camera = 'Back';\n      }\n    }\n\n    let drawBox = null;\n\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        return React.createElement(\"div\", {\n          key: i,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 110\n          },\n          __self: this\n        }, React.createElement(\"div\", {\n          style: {\n            position: 'absolute',\n            border: 'solid',\n            borderColor: 'blue',\n            height: _H,\n            width: _W,\n            transform: \"translate(\".concat(_X, \"px,\").concat(_Y, \"px)\")\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 111\n          },\n          __self: this\n        }, !!match && !!match[i] ? React.createElement(\"p\", {\n          style: {\n            backgroundColor: 'blue',\n            border: 'solid',\n            borderColor: 'blue',\n            width: _W,\n            marginTop: 0,\n            color: '#fff',\n            transform: \"translate(-3px,\".concat(_H, \"px)\")\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 122\n          },\n          __self: this\n        }, match[i]._label) : null));\n      });\n    }\n\n    return React.createElement(\"div\", {\n      className: \"Camera\",\n      style: {\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center'\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 143\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 151\n      },\n      __self: this\n    }, \"Camera: \", camera), React.createElement(\"div\", {\n      style: {\n        width: WIDTH,\n        height: HEIGHT\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      style: {\n        position: 'relative',\n        width: WIDTH\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 158\n      },\n      __self: this\n    }, !!videoConstraints ? React.createElement(\"div\", {\n      style: {\n        position: 'absolute'\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160\n      },\n      __self: this\n    }, React.createElement(Webcam, {\n      audio: false,\n      width: WIDTH,\n      height: HEIGHT,\n      ref: this.webcam,\n      screenshotFormat: \"image/jpeg\",\n      videoConstraints: videoConstraints,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161\n      },\n      __self: this\n    })) : null, !!drawBox ? drawBox : null)));\n  }\n\n}\n\nexport default withRouter(VideoInput);","map":{"version":3,"sources":["/Users/adila/Desktop/face-recognition-adila/src/views/VideoInput.js"],"names":["React","Component","withRouter","Webcam","loadModels","getFullFaceDescription","createMatcher","JSON_PROFILE","require","WIDTH","HEIGHT","inputSize","VideoInput","constructor","props","componentWillMount","setState","faceMatcher","setInputDevice","navigator","mediaDevices","enumerateDevices","then","devices","inputDevice","filter","device","kind","length","facingMode","startCapture","interval","setInterval","capture","webcam","current","getScreenshot","fullDesc","detections","map","fd","detection","descriptors","descriptor","state","match","findBestMatch","createRef","componentWillUnmount","clearInterval","render","videoConstraints","camera","width","height","drawBox","i","_H","box","_W","_X","_x","_Y","_y","position","border","borderColor","transform","backgroundColor","marginTop","color","_label","display","flexDirection","alignItems"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face';\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/bnk48.json');\n\nconst WIDTH = 420;\nconst HEIGHT = 420;\nconst inputSize = 160;\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      descriptors: null,\n      faceMatcher: null,\n      match: null,\n      facingMode: null\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      let inputDevice = await devices.filter(\n        device => device.kind === 'videoinput'\n      );\n      if (inputDevice.length < 2) {\n        await this.setState({\n          facingMode: 'user'\n        });\n      } else {\n        await this.setState({\n          facingMode: 'user'\n          //facingMode: { exact: 'environment' } //capture from back camera\n        });\n      }\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 1500);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          this.setState({\n            detections: fullDesc.map(fd => fd.detection),\n            descriptors: fullDesc.map(fd => fd.descriptor)\n          });\n        }\n      });\n\n      if (!!this.state.descriptors && !!this.state.faceMatcher) {\n        let match = await this.state.descriptors.map(descriptor =>\n          this.state.faceMatcher.findBestMatch(descriptor)\n        );\n        this.setState({ match });\n      }\n    }\n  };\n\n  render() {\n    const { detections, match, facingMode } = this.state;\n    let videoConstraints = null;\n    let camera = '';\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n      if (facingMode === 'user') {\n        camera = 'Front';\n      } else {\n        camera = 'Back';\n      }\n    }\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: 'blue',\n                height: _H,\n                width: _W,\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {!!match && !!match[i] ? (\n                <p\n                  style={{\n                    backgroundColor: 'blue',\n                    border: 'solid',\n                    borderColor: 'blue',\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  {match[i]._label}\n                </p>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div\n        className=\"Camera\"\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center'\n        }}\n      >\n        <p>Camera: {camera}</p>\n        <div\n          style={{\n            width: WIDTH,\n            height: HEIGHT\n          }}\n        >\n          <div style={{ position: 'relative', width: WIDTH }}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {!!drawBox ? drawBox : null}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default withRouter(VideoInput);"]},"metadata":{},"sourceType":"module"}